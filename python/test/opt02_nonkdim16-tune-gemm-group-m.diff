diff --git a/python/test/triton_tem_fused_addmm_130.py b/python/test/triton_tem_fused_addmm_130.py
index fa73de8a5..f4c9a06bc 100755
--- a/python/test/triton_tem_fused_addmm_130.py
+++ b/python/test/triton_tem_fused_addmm_130.py
@@ -219,7 +219,12 @@ def get_triton_autotune_configs() -> list[triton.Config]:


 @triton.autotune(configs=get_triton_autotune_configs(), key=["M", "N", "K"])
-@triton.heuristics({"EVEN_K": lambda args: args["K"] % args["BLOCK_K"] == 0})
+@triton.heuristics({
+    "EVEN_K":
+    lambda args: args["K"] % args["BLOCK_K"] == 0,
+    "GRID_MN":
+    lambda args: triton.cdiv(args["M"], args["BLOCK_M"]) * triton.cdiv(args["N"], args["BLOCK_N"]),
+})
 @triton.jit
 def triton_tem_fused_addmm_130_kernel_opt(in_ptr0, A, B, out_ptr0,  #
                                           M: int, N: int, K: int,  #
@@ -228,24 +233,36 @@ def triton_tem_fused_addmm_130_kernel_opt(in_ptr0, A, B, out_ptr0,  #
                                           stride_cm: int, stride_cn: int,  #
                                           stride_xxx: int,  #
                                           BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,  #
-                                          GROUP_M: tl.constexpr, EVEN_K: tl.constexpr):
+                                          GROUP_M: tl.constexpr, EVEN_K: tl.constexpr,  #
+                                          GRID_MN: tl.constexpr):
     ACC_TYPE: tl.constexpr = tl.float32

     if M * N == 0:
         # early exit due to zero-size input(s)
         return

-    # based on triton.ops.matmul
-    pid = tl.program_id(0)
-    grid_m = (M + BLOCK_M - 1) // BLOCK_M
-    grid_n = (N + BLOCK_N - 1) // BLOCK_N
-
-    # re-order program ID for better L2 performance
-    width = GROUP_M * grid_n
-    group_id = pid // width
-    group_size = min(grid_m - group_id * GROUP_M, GROUP_M)
-    pid_m = group_id * GROUP_M + (pid % group_size)
-    pid_n = (pid % width) // (group_size)
+    pid = tl.program_id(axis=0)
+    num_pid_m = tl.cdiv(M, BLOCK_M)
+    num_pid_n = tl.cdiv(N, BLOCK_N)
+    NUM_XCDS: tl.constexpr = 8
+    ## pid remapping on xcds
+    # Number of pids per XCD in the new arrangement
+    pids_per_xcd = GRID_MN // NUM_XCDS
+    # Compute current XCD and local pid within the XCD
+    xcd = pid % NUM_XCDS
+    local_pid = pid // NUM_XCDS
+    # Calculate new pid based on the new grouping
+    pid = xcd * pids_per_xcd + local_pid
+    if GROUP_M == 1:
+        pid_m = pid // num_pid_n
+        pid_n = pid % num_pid_n
+    else:
+        num_pid_in_group = GROUP_M * num_pid_n
+        group_id = pid // num_pid_in_group
+        first_pid_m = group_id * GROUP_M
+        group_size_m = min(num_pid_m - first_pid_m, GROUP_M)
+        pid_m = first_pid_m + ((pid % num_pid_in_group) % group_size_m)
+        pid_n = (pid % num_pid_in_group) // group_size_m

     rm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)
     rn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)
